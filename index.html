<!DOCTYPE html>
<html>
<head>
    <title>è´ªåƒè›‡</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            min-height: 100vh;
        }
        .game-container {
            text-align: center;
            margin: 1vh auto;
            padding: 2vh;
            width: 95vw;
            height: 95vh;
            max-width: 1000px;
            max-height: 1000px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(76, 175, 80, 0.3);
            box-shadow: 0 0 50px rgba(76, 175, 80, 0.2),
                        inset 0 0 20px rgba(76, 175, 80, 0.1);
        }
        #gameCanvas {
            width: 80vmin;
            height: 80vmin;
            max-width: 600px;
            max-height: 600px;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            background: #000;
            box-shadow: 0 0 40px rgba(76, 175, 80, 0.4),
                        inset 0 0 20px rgba(76, 175, 80, 0.2);
        }
        #score {
            position: relative;
            font-size: 40px;
            font-family: 'Arial Black', sans-serif;
            color: #4CAF50;
            text-shadow: 0 0 10px #4CAF50;
            margin: 20px 0;
            letter-spacing: 2px;
            animation: scoreGlow 2s ease-in-out infinite;
        }
        @keyframes scoreGlow {
            0%, 100% { text-shadow: 0 0 10px #4CAF50; }
            50% { text-shadow: 0 0 20px #4CAF50; }
        }
        #gameOver {
            display: none;
            color: #FF4081;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-top: 30px;
            padding: 15px;
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            animation: glow 1.5s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #FF4081; }
            to { text-shadow: 0 0 20px #fff, 0 0 30px #FF4081, 0 0 40px #FF4081; }
        }
        /* æ–°å¢æ§åˆ¶é¢æ¿æ ·å¼ */
        .control-panel {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 20px;
            opacity: 1; /* ç¡®ä¿é»˜è®¤å¯è§ */
            transition: opacity 0.3s; /* æ·»åŠ æ¸å˜æ•ˆæœ */
        }
        .control-btn {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            transition: all 0.4s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            position: relative;
            overflow: hidden;
        }
        .control-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                45deg,
                transparent,
                rgba(255,255,255,0.2),
                transparent
            );
            transform: rotate(45deg);
            transition: all 0.4s;
        }
        .control-btn:hover::before {
            animation: btnGlow 1.5s ease-in-out;
        }
        @keyframes btnGlow {
            0% { transform: rotate(45deg) translate(-50%, -50%); }
            100% { transform: rotate(45deg) translate(50%, 50%); }
        }
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.5);
            opacity: 1; /* ç¡®ä¿æ‚¬åœæ—¶å®Œå…¨å¯è§ */
        }
        #difficulty {
            padding: 10px;
            border-radius: 15px;
            background: rgba(0,0,0,0.6);
            color: #4CAF50; /* ä¿®æ”¹æ–‡æœ¬é¢œè‰²ä¸ºç»¿è‰² */
            border: 2px solid #4CAF50;
            font-size: 16px;
            appearance: none; /* ç§»é™¤é»˜è®¤æ ·å¼ */
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%234CAF50%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 0.7em top 50%;
            background-size: 0.65em auto;
            padding-right: 2em;
        }
        /* ä¸‹æ‹‰é€‰é¡¹æ ·å¼ */
        #difficulty option {
            background: rgba(0,0,0,0.9);
            color: #4CAF50;
            font-size: 14px;
        }
        /* æ§åˆ¶é¢æ¿æ‚¬åœæ•ˆæœ */
        .game-container:hover .control-panel {
            opacity: 1; /* ä¿æŒå§‹ç»ˆå¯è§ */
        }
        /* æ–°å¢åŠ¨æ€èƒŒæ™¯ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                45deg,
                rgba(76, 175, 80, 0.1) 25%,
                transparent 25%,
                transparent 75%,
                rgba(76, 175, 80, 0.1) 75%,
                rgba(76, 175, 80, 0.1)
            ),
            linear-gradient(
                45deg,
                rgba(76, 175, 80, 0.1) 25%,
                transparent 25%,
                transparent 75%,
                rgba(76, 175, 80, 0.1) 75%,
                rgba(76, 175, 80, 0.1)
            );
            background-size: 50px 50px;
            background-position: 0 0, 25px 25px;
            z-index: -1;
            animation: bgMove 20s linear infinite;
        }
        @keyframes bgMove {
            0% { background-position: 0 0, 25px 25px; }
            100% { background-position: 50px 50px, 75px 75px; }
        }
        /* é£Ÿç‰©åŠ¨ç”» */
        .food-glow {
            animation: foodPulse 1.5s ease-in-out infinite;
        }
        @keyframes foodPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
        }
        @keyframes foodGlow {
            0% { filter: brightness(100%); }
            50% { filter: brightness(150%); }
            100% { filter: brightness(100%); }
        }
        /* å†å²è®°å½•æŒ‰é’®æ ·å¼ */
        #historyBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            transition: all 0.3s;
        }
        #historyBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.5);
        }
        /* å†å²è®°å½•é¢æ¿æ ·å¼ */
        #historyPanel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #4CAF50;
            border-radius: 15px;
            padding: 20px;
            color: #4CAF50;
            z-index: 1000;
            overflow-y: auto;
        }
        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 10px;
            transition: all 0.3s;
        }
        .history-item:hover {
            background: rgba(76, 175, 80, 0.2);
        }
        .history-info {
            flex: 1;
        }
        .history-score {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .history-date {
            font-size: 14px;
            opacity: 0.8;
        }
        .replay-btn {
            padding: 8px 16px;
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            margin-left: 15px;
            transition: all 0.3s;
        }
        .replay-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        .replay-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #closeHistoryBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #4CAF50;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }
        #closeHistoryBtn:hover {
            transform: scale(1.1);
            color: #FF4081;
        }
        /* å›æ”¾é®ç½©å±‚ */
        #replayOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
        }
        /* å›æ”¾æ§åˆ¶é¢æ¿ */
        #replayControls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 25px;
            z-index: 1001;
        }
        .replay-control-btn {
            padding: 8px 16px;
            margin: 0 5px;
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .replay-control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        #replaySpeed {
            padding: 5px;
            margin: 0 10px;
            background: rgba(0, 0, 0, 0.6);
            color: #4CAF50;
            border: 1px solid #4CAF50;
            border-radius: 10px;
        }
        /* æ·»åŠ ä½œè€…ä¿¡æ¯æ ·å¼ */
        .author-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #4CAF50;
            font-size: 14px;
            font-family: Arial, sans-serif;
            text-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
        }
        .author-info a {
            color: #4CAF50;
            text-decoration: none;
            transition: all 0.3s ease;
        }
        .author-info a:hover {
            color: #81C784;
            text-shadow: 0 0 15px rgba(76, 175, 80, 0.8);
        }
    </style>
</head>
<body>
    <div class="author-info">
        ä½œè€…ï¼š <a href="https://github.com/ikdxhz" target="_blank">ikdxhz</a>
    </div>
    <button id="historyBtn">å†å²è®°å½•</button>
    
    <div id="historyPanel">
        <button id="closeHistoryBtn">Ã—</button>
        <h2 style="text-align: center; margin-bottom: 20px;">æ¸¸æˆå†å²è®°å½•</h2>
        <div id="historyList"></div>
    </div>

    <div id="replayOverlay"></div>
    <div id="replayControls">
        <button class="replay-control-btn" id="replayPause">æš‚åœ</button>
        <select id="replaySpeed">
            <option value="0.5">0.5x</option>
            <option value="1" selected>1.0x</option>
            <option value="2">2.0x</option>
            <option value="4">4.0x</option>
        </select>
        <button class="replay-control-btn" id="replayStop">åœæ­¢</button>
    </div>

    <div class="game-container">
        <div id="score">å¾—åˆ†: 0</div>
        <div class="control-panel">
            <select id="difficulty">
                <option value="100">èŒæ–°æ¨¡å¼</option>
                <option value="80">ç®€å•æ¨¡å¼</option>
                <option value="60" selected>æ™®é€šæ¨¡å¼</option>
                <option value="40">å›°éš¾æ¨¡å¼</option>
                <option value="20">åœ°ç‹±æ¨¡å¼</option>
            </select>
            <button id="aiToggle" class="control-btn">AIæ‰˜ç®¡</button>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="gameOver" style="display: none; color: red; font-size: 32px; margin-top: 20px;">
            æ¸¸æˆç»“æŸï¼ç‚¹å‡»ä»»æ„é”®é‡æ–°å¼€å§‹
        </div>
    </div>

    <!-- æ–°å¢è°ƒè¯•é¢æ¿ -->
    <div id="debugPanel" style="position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: #4CAF50; padding: 10px; border-radius: 5px; font-family: monospace; max-width: 300px; display: none;">
        <label><input type="checkbox" id="debugToggle"> æ˜¾ç¤ºAIæ€è€ƒ</label>
        <div id="debugLog" style="max-height: 200px; overflow-y: auto; margin-top: 5px;"></div>
    </div>

    <script>
        let Game;
        (function() {
            Game = {
                CONFIG: {
                    GRID_SIZE: 20,
                    INITIAL_SPEED: 60,
                    COLOR: {
                        SNAKE_HEAD: '#4CAF50',
                        SNAKE_BODY: '#388E3C',
                        FOOD: ['#FF4081', '#FFC107', '#4CAF50', '#2196F3'],
                        SPECIAL_FOOD: '#FF5722',
                        BACKGROUND: '#000'
                    },
                    SPECIAL_FOOD_CHANCE: 0.1, // ç‰¹æ®Šé£Ÿç‰©å‡ºç°æ¦‚ç‡
                    SPECIAL_FOOD_BONUS: 30,   // ç‰¹æ®Šé£Ÿç‰©é¢å¤–å¾—åˆ†
                    COMBO_TIMEOUT: 5000       // è¿å‡»æ—¶é—´çª—å£ï¼ˆæ¯«ç§’ï¼‰
                },

                state: {
                    snake: [],
                    food: {},
                    dx: 0,
                    dy: 0,
                    score: 0,
                    isGameOver: false,
                    isAIEnabled: false,
                    difficulty: 60,
                    path: [],
                    gameStarted: false,
                    resetCountdown: 0,
                    isPaused: false,
                    showTips: true,
                    tipsFadeOut: 0,
                    userControlTimeout: 0,
                    moveHistory: [], // å½“å‰æ¸¸æˆçš„ç§»åŠ¨è®°å½•
                    isReplaying: false, // æ˜¯å¦æ­£åœ¨å›æ”¾
                    replayPaused: false, // å›æ”¾æ˜¯å¦æš‚åœ
                    specialFood: null,        // ç‰¹æ®Šé£Ÿç‰©ä½ç½®
                    comboCount: 0,           // è¿å‡»æ¬¡æ•°
                    lastFoodTime: 0,         // ä¸Šæ¬¡åƒåˆ°é£Ÿç‰©çš„æ—¶é—´
                    effects: [],             // ç‰¹æ•ˆæ•°ç»„
                    powerups: [],           // é“å…·æ•°ç»„
                },

                // å†å²è®°å½•ç›¸å…³
                gameHistory: [], // å­˜å‚¨å†å²è®°å½•
                
                foodHistory: [], // å­˜å‚¨é£Ÿç‰©ä½ç½®å†å²
                
                init() {
                    this.loadHistory();
                    this.cacheElements();
                    this.initCanvas();
                    this.bindEvents();
                    this.bindHistoryEvents();
                    this.foodHistory = []; // åˆå§‹åŒ–é£Ÿç‰©ä½ç½®å†å²
                    this.resetGame();
                    this.startGame();
                },

                // åŠ è½½å†å²è®°å½•
                loadHistory() {
                    const savedHistory = localStorage.getItem('snakeGameHistory');
                    this.gameHistory = savedHistory ? JSON.parse(savedHistory) : [];
                },

                // ä¿å­˜å†å²è®°å½•
                saveHistory() {
                    if (this.state.score === 0) {
                        return; // ä¸ä¿å­˜é›¶åˆ†è®°å½•
                    }

                    const newRecord = {
                        date: new Date().toLocaleString(),
                        score: this.state.score,
                        moves: this.state.moveHistory,
                        length: this.state.snake.length,
                        difficulty: this.state.difficulty,
                        // è®°å½•å®Œæ•´çš„æ¸¸æˆçŠ¶æ€
                        initialState: {
                            snake: [{x: 10, y: 10}], // åˆå§‹è›‡çš„ä½ç½®
                            food: {x: 15, y: 15},    // åˆå§‹é£Ÿç‰©ä½ç½®
                            score: 0,                 // åˆå§‹åˆ†æ•°
                            dx: 1,                    // åˆå§‹ç§»åŠ¨æ–¹å‘
                            dy: 0
                        },
                        foodHistory: this.foodHistory || [], // é£Ÿç‰©å†å²
                        snakeGrowth: this.state.snake.length - 1 // è®°å½•è›‡çš„ç”Ÿé•¿å†å²
                    };

                    this.gameHistory.unshift(newRecord);
                    if (this.gameHistory.length > 10) {
                        this.gameHistory.pop();
                    }

                    try {
                        localStorage.setItem('snakeGameHistory', JSON.stringify(this.gameHistory));
                        this.showMessage('æ¸¸æˆè®°å½•å·²ä¿å­˜', 'info');
                    } catch (error) {
                        console.error('ä¿å­˜å†å²è®°å½•å¤±è´¥:', error);
                        this.showMessage('ä¿å­˜æ¸¸æˆè®°å½•å¤±è´¥', 'error');
                    }
                    this.updateHistoryPanel();
                },

                // æ›´æ–°å†å²è®°å½•é¢æ¿
                updateHistoryPanel() {
                    const historyList = document.getElementById('historyList');
                    if (this.gameHistory.length === 0) {
                        historyList.innerHTML = `
                            <div style="text-align: center; padding: 30px; color: #666;">
                                <div style="font-size: 40px; margin-bottom: 10px;">ğŸ®</div>
                                <div style="font-size: 18px;">è¿˜æ²¡æœ‰æ¸¸æˆè®°å½•</div>
                                <div style="font-size: 14px; margin-top: 10px;">å¼€å§‹ä¸€å±€æ¸¸æˆæ¥åˆ›å»ºå†å²è®°å½•å§ï¼</div>
                            </div>
                        `;
                        return;
                    }

                    historyList.innerHTML = this.gameHistory.map((record, index) => `
                        <div class="history-item">
                            <div class="history-info">
                                <div class="history-score">å¾—åˆ†: ${record.score}</div>
                                <div class="history-date">${record.date}</div>
                                <div>è›‡é•¿åº¦: ${record.length}</div>
                                <div>éš¾åº¦: ${this.getDifficultyName(record.difficulty)}</div>
                            </div>
                            <button class="replay-btn" ${index < 5 ? '' : 'disabled'}
                                onclick="event.preventDefault(); Game.startReplay(${index})"
                                ${index >= 5 ? 'title="åªæœ‰æœ€è¿‘5å±€å¯ä»¥å›æ”¾"' : ''}>
                                ${index < 5 ? 'å›æ”¾' : 'ä¸å¯å›æ”¾'}
                            </button>
                        </div>
                    `).join('');
                },

                // ç»‘å®šå†å²è®°å½•ç›¸å…³äº‹ä»¶
                bindHistoryEvents() {
                    const historyBtn = document.getElementById('historyBtn');
                    const historyPanel = document.getElementById('historyPanel');
                    const closeHistoryBtn = document.getElementById('closeHistoryBtn');
                    const replayOverlay = document.getElementById('replayOverlay');
                    const replayControls = document.getElementById('replayControls');
                    const replayPause = document.getElementById('replayPause');
                    const replayStop = document.getElementById('replayStop');
                    const replaySpeed = document.getElementById('replaySpeed');

                    // æ˜¾ç¤ºå†å²è®°å½•é¢æ¿
                    historyBtn.addEventListener('click', () => {
                        historyPanel.style.display = 'block';
                        this.updateHistoryPanel();
                    });

                    // å…³é—­å†å²è®°å½•é¢æ¿
                    closeHistoryBtn.addEventListener('click', () => {
                        historyPanel.style.display = 'none';
                    });

                    // å›æ”¾æ§åˆ¶
                    replayPause.addEventListener('click', () => {
                        if (this.state.isReplaying) {
                            this.state.replayPaused = !this.state.replayPaused;
                            replayPause.textContent = this.state.replayPaused ? 'ç»§ç»­' : 'æš‚åœ';
                            if (!this.state.replayPaused) {
                                this.replayNextMove(); // ç»§ç»­å›æ”¾
                            }
                        }
                    });

                    replayStop.addEventListener('click', () => {
                        this.stopReplay();
                    });

                    replaySpeed.addEventListener('change', (e) => {
                        if (this.state.isReplaying) {
                            this.state.replaySpeed = parseFloat(e.target.value);
                        }
                    });
                },

                cacheElements() {
                    this.canvas = document.getElementById('gameCanvas');
                    this.ctx = this.canvas.getContext('2d');
                    this.elements = {
                        score: document.getElementById('score'),
                        gameOver: document.getElementById('gameOver'),
                        difficulty: document.getElementById('difficulty'),
                        aiToggle: document.getElementById('aiToggle'),
                        debugPanel: document.getElementById('debugPanel'),
                        debugToggle: document.getElementById('debugToggle'),
                        debugLog: document.getElementById('debugLog')
                    };
                },

                initCanvas() {
                    const canvasSize = Math.min(window.innerWidth * 0.8, 600);
                    this.canvas.width = canvasSize;
                    this.canvas.height = canvasSize;
                    this.tileCount = this.canvas.width / this.CONFIG.GRID_SIZE;
                },

                resetGame() {
                    this.state = {
                        snake: [{ x: 10, y: 10 }],
                        food: { x: 15, y: 15 },
                        dx: 0,
                        dy: 0,
                        score: 0,
                        isGameOver: false,
                        isAIEnabled: false,
                        difficulty: parseInt(this.elements.difficulty.value),
                        path: [],
                        gameStarted: false,
                        resetCountdown: 0,
                        isPaused: false,
                        showTips: true,
                        tipsFadeOut: 2000,
                        userControlTimeout: 0,
                        moveHistory: [], // é‡ç½®ç§»åŠ¨å†å²
                        isReplaying: false, // é‡ç½®å›æ”¾çŠ¶æ€
                        replayPaused: false, // é‡ç½®å›æ”¾æš‚åœçŠ¶æ€
                        replaySpeed: 1, // é‡ç½®å›æ”¾é€Ÿåº¦
                        specialFood: null,        // ç‰¹æ®Šé£Ÿç‰©ä½ç½®
                        comboCount: 0,           // è¿å‡»æ¬¡æ•°
                        lastFoodTime: 0,         // ä¸Šæ¬¡åƒåˆ°é£Ÿç‰©çš„æ—¶é—´
                        effects: [],             // ç‰¹æ•ˆæ•°ç»„
                        powerups: [],           // é“å…·æ•°ç»„
                    };
                    this.elements.score.textContent = 'å¾—åˆ†: 0';
                    this.elements.gameOver.style.display = 'none';
                    this.elements.aiToggle.textContent = "AIæ‰˜ç®¡";
                    
                    // ç”Ÿæˆåˆå§‹é£Ÿç‰©
                    this.generateFood();
                    
                    // æ˜¾ç¤ºå¼€å§‹æç¤º
                    this.showMessage('æŒ‰ä»»æ„é”®æˆ–ç‚¹å‡»å¼€å§‹æ¸¸æˆ', 'info');
                },

                startGame() {
                    if (this.gameLoop) cancelAnimationFrame(this.gameLoop);
                    this.lastTick = performance.now();
                    this.animate();
                },

                animate() {
                    const now = performance.now();
                    if (now - this.lastTick >= this.state.difficulty) {
                        this.update();
                        this.draw();
                        this.lastTick = now;
                    }
                    this.gameLoop = requestAnimationFrame(() => this.animate());
                },

                update() {
                    if (this.state.isGameOver) {
                        if (this.state.resetCountdown > 0) {
                            this.state.resetCountdown -= this.state.difficulty;
                            if (this.state.resetCountdown <= 0) {
                                this.saveHistory();
                                this.showMessage('æ¸¸æˆç»“æŸï¼ŒæŒ‰ä»»æ„é”®é‡æ–°å¼€å§‹', 'warning');
                            }
                        }
                        return;
                    }
                    
                    if (!this.state.gameStarted || this.state.isPaused) {
                        return;
                    }

                    // æ›´æ–°ç‰¹æ•ˆ
                    this.state.effects = this.state.effects.filter(effect => {
                        effect.duration -= this.state.difficulty;
                        return effect.duration > 0;
                    });

                    // æ›´æ–°é“å…·
                    this.state.powerups = this.state.powerups.filter(powerup => {
                        powerup.duration -= this.state.difficulty;
                        return powerup.duration > 0;
                    });

                    if (this.state.dx === 0 && this.state.dy === 0) {
                        return;
                    }
                    
                    if (this.state.isAIEnabled) {
                        this.updateAI();
                    }

                    const head = { 
                        x: this.state.snake[0].x + this.state.dx, 
                        y: this.state.snake[0].y + this.state.dy 
                    };

                    if (this.checkCollision(head)) {
                        this.state.isGameOver = true;
                        this.state.resetCountdown = 3000;
                        this.addEffect('explosion', head.x, head.y);
                        return;
                    }

                    this.state.snake.unshift(head);

                    // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
                    let ate = false;
                    if (head.x === this.state.food.x && head.y === this.state.food.y) {
                        const now = Date.now();
                        // æ£€æŸ¥è¿å‡»
                        if (now - this.state.lastFoodTime < this.CONFIG.COMBO_TIMEOUT) {
                            this.state.comboCount++;
                            const comboBonus = this.state.comboCount * 5;
                            this.state.score += 10 + comboBonus;
                            this.addEffect('combo', head.x, head.y, `+${comboBonus}`);
                        } else {
                            this.state.comboCount = 1;
                            this.state.score += 10;
                        }
                        this.state.lastFoodTime = now;
                        this.elements.score.textContent = `å¾—åˆ†: ${this.state.score}`;
                        this.generateFood();
                        ate = true;
                        this.addEffect('eat', head.x, head.y);
                    } else if (this.state.specialFood && 
                               head.x === this.state.specialFood.x && 
                               head.y === this.state.specialFood.y) {
                        this.state.score += this.CONFIG.SPECIAL_FOOD_BONUS;
                        this.elements.score.textContent = `å¾—åˆ†: ${this.state.score}`;
                        this.state.specialFood = null;
                        ate = true;
                        this.addEffect('special', head.x, head.y);
                        this.addPowerup();
                    }

                    if (!ate) {
                        this.state.snake.pop();
                    }

                    this.updatePositionCache();

                    if (!this.state.isReplaying && (this.state.dx !== 0 || this.state.dy !== 0)) {
                        this.state.moveHistory.push([this.state.dx, this.state.dy]);
                    }
                },

                draw() {
                    // æ¸…ç©ºç”»å¸ƒ
                    this.ctx.fillStyle = this.CONFIG.COLOR.BACKGROUND;
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    // ç»˜åˆ¶é£Ÿç‰©
                    this.drawFood();
                    
                    // ç»˜åˆ¶è›‡
                    this.drawSnake();

                    // ç»˜åˆ¶æ¸¸æˆçŠ¶æ€æç¤º
                    if (this.state.isGameOver) {
                        this.drawGameOver();
                    } else if (!this.state.gameStarted) {
                        this.drawStartPrompt();
                    } else if (this.state.isPaused) {
                        this.drawPausePrompt();
                    }

                    // ç»˜åˆ¶æ§åˆ¶æç¤º
                    this.drawControlTips();

                    // ç»˜åˆ¶ç‰¹æ®Šé£Ÿç‰©
                    if (this.state.specialFood) {
                        const size = this.CONFIG.GRID_SIZE * 0.8;
                        const x = this.state.specialFood.x * this.CONFIG.GRID_SIZE + this.CONFIG.GRID_SIZE/2;
                        const y = this.state.specialFood.y * this.CONFIG.GRID_SIZE + this.CONFIG.GRID_SIZE/2;

                        this.ctx.save();
                        this.ctx.shadowColor = this.CONFIG.COLOR.SPECIAL_FOOD;
                        this.ctx.shadowBlur = 20;
                        this.ctx.fillStyle = this.CONFIG.COLOR.SPECIAL_FOOD;
                        
                        // ç»˜åˆ¶æ˜Ÿå½¢
                        this.ctx.beginPath();
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                            const x1 = x + Math.cos(angle) * size;
                            const y1 = y + Math.sin(angle) * size;
                            if (i === 0) {
                                this.ctx.moveTo(x1, y1);
                            } else {
                                this.ctx.lineTo(x1, y1);
                            }
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.restore();
                    }

                    // ç»˜åˆ¶ç‰¹æ•ˆ
                    this.state.effects.forEach(effect => {
                        this.ctx.save();
                        this.ctx.globalAlpha = effect.duration / 500;
                        
                        switch(effect.type) {
                            case 'explosion':
                                this.drawExplosion(effect);
                                break;
                            case 'eat':
                                this.drawEatEffect(effect);
                                break;
                            case 'combo':
                                this.drawComboEffect(effect);
                                break;
                            case 'special':
                                this.drawSpecialEffect(effect);
                                break;
                        }
                        
                        this.ctx.restore();
                    });

                    // ç»˜åˆ¶é“å…·çŠ¶æ€
                    this.drawPowerups();
                },

                drawFood() {
                    const foodSize = this.CONFIG.GRID_SIZE * 0.8;
                    const foodX = this.state.food.x * this.CONFIG.GRID_SIZE + this.CONFIG.GRID_SIZE/2;
                    const foodY = this.state.food.y * this.CONFIG.GRID_SIZE + this.CONFIG.GRID_SIZE/2;

                    this.ctx.shadowColor = this.getFoodColor(this.state.score);
                    this.ctx.shadowBlur = 15;
                    this.ctx.fillStyle = this.getFoodColor(this.state.score);
                    this.ctx.beginPath();
                    this.ctx.arc(foodX, foodY, foodSize/2, 0, Math.PI * 2);
                    this.ctx.fill();

                    // é‡ç½®é˜´å½±
                    this.ctx.shadowBlur = 0;
                },

                drawSnake() {
                    this.state.snake.forEach((segment, index) => {
                        const gradient = this.getCachedGradient(
                            segment.x * this.CONFIG.GRID_SIZE,
                            segment.y * this.CONFIG.GRID_SIZE,
                            segment.x * this.CONFIG.GRID_SIZE + this.CONFIG.GRID_SIZE,
                            segment.y * this.CONFIG.GRID_SIZE + this.CONFIG.GRID_SIZE,
                            index === 0 ? 
                                [this.CONFIG.COLOR.SNAKE_HEAD, this.CONFIG.COLOR.SNAKE_BODY] :
                                [this.CONFIG.COLOR.SNAKE_BODY, this.CONFIG.COLOR.SNAKE_BODY]
                        );

                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.roundRect(
                            segment.x * this.CONFIG.GRID_SIZE + 1,
                            segment.y * this.CONFIG.GRID_SIZE + 1,
                            this.CONFIG.GRID_SIZE - 2,
                            this.CONFIG.GRID_SIZE - 2,
                            5
                        );
                        this.ctx.fill();

                        // ç»˜åˆ¶è›‡çœ¼
                        if (index === 0) {
                            this.drawSnakeEyes(segment);
                        }
                    });
                },

                drawSnakeEyes(head) {
                    this.ctx.fillStyle = '#000';
                    this.ctx.beginPath();
                    this.ctx.arc(
                        head.x * this.CONFIG.GRID_SIZE + this.CONFIG.GRID_SIZE/3,
                        head.y * this.CONFIG.GRID_SIZE + this.CONFIG.GRID_SIZE/3,
                        2, 0, Math.PI * 2
                    );
                    this.ctx.arc(
                        head.x * this.CONFIG.GRID_SIZE + this.CONFIG.GRID_SIZE - this.CONFIG.GRID_SIZE/3,
                        head.y * this.CONFIG.GRID_SIZE + this.CONFIG.GRID_SIZE/3,
                        2, 0, Math.PI * 2
                    );
                    this.ctx.fill();
                },

                generateFood() {
                    do {
                        this.state.food = {
                            x: Math.floor(Math.random() * this.tileCount),
                            y: Math.floor(Math.random() * this.tileCount)
                        };
                    } while (this.state.snake.some(segment => 
                        segment.x === this.state.food.x && segment.y === this.state.food.y));

                    // è®°å½•é£Ÿç‰©ä½ç½®
                    if (!this.state.isReplaying) {
                        this.foodHistory = this.foodHistory || [];
                        this.foodHistory.push({...this.state.food});
                    }

                    // éšæœºç”Ÿæˆç‰¹æ®Šé£Ÿç‰©
                    if (Math.random() < this.CONFIG.SPECIAL_FOOD_CHANCE) {
                        do {
                            this.state.specialFood = {
                                x: Math.floor(Math.random() * this.tileCount),
                                y: Math.floor(Math.random() * this.tileCount)
                            };
                        } while (
                            (this.state.specialFood.x === this.state.food.x && 
                             this.state.specialFood.y === this.state.food.y) ||
                            this.state.snake.some(segment => 
                                segment.x === this.state.specialFood.x && 
                                segment.y === this.state.specialFood.y)
                        );
                    } else {
                        this.state.specialFood = null;
                    }
                },

                updatePositionCache() {
                    this.positionCache = new Set(
                        this.state.snake.map(segment => `${segment.x},${segment.y}`)
                    );
                },

                checkCollision(head) {
                    return head.x < 0 || head.x >= this.tileCount ||
                           head.y < 0 || head.y >= this.tileCount ||
                           this.state.snake.slice(1).some(segment => 
                               segment.x === head.x && segment.y === head.y);
                },

                getFoodColor(index) {
                    return this.CONFIG.COLOR.FOOD[index % this.CONFIG.COLOR.FOOD.length];
                },

                getCachedGradient(x1, y1, x2, y2, colors) {
                    const key = `${x1}-${y1}-${x2}-${y2}-${colors.join('-')}`;
                    if (!this.gradientCache) this.gradientCache = new Map();
                    if (!this.gradientCache.has(key)) {
                        const gradient = this.ctx.createLinearGradient(x1, y1, x2, y2);
                        gradient.addColorStop(0, colors[0]);
                        gradient.addColorStop(1, colors[1]);
                        this.gradientCache.set(key, gradient);
                    }
                    return this.gradientCache.get(key);
                },

                bindEvents() {
                    // é”®ç›˜æ§åˆ¶
                    document.addEventListener('keydown', (e) => {
                        if (e.key === ' ') { // ç©ºæ ¼é”®æš‚åœ
                            if (this.state.gameStarted && !this.state.isGameOver) {
                                this.state.isPaused = !this.state.isPaused;
                                if (this.state.isPaused) {
                                    this.state.showTips = true;
                                    this.showMessage('æ¸¸æˆå·²æš‚åœ', 'info');
                                } else {
                                    this.state.tipsFadeOut = 2000; // 2ç§’åæ·¡å‡ºæç¤º
                                    this.showMessage('æ¸¸æˆç»§ç»­', 'info');
                                }
                                return;
                            }
                        }

                        if (this.state.isPaused && e.key !== ' ') {
                            return;
                        }
                        
                        if (this.state.isGameOver) {
                            if (this.state.resetCountdown <= 0) {
                                this.resetGame();
                                this.state.gameStarted = true;
                                this.showMessage('æ¸¸æˆå¼€å§‹', 'info');
                            }
                            return;
                        }

                        if (!this.state.gameStarted) {
                            this.state.gameStarted = true;
                            this.state.showTips = true;
                            this.state.tipsFadeOut = 2000; // 2ç§’åæ·¡å‡ºæç¤º
                            this.state.tipsFadeOut = 2000; // 2ç§’åæ·¡å‡ºæç¤º
                            this.state.showTips = true;
                            this.state.tipsFadeOut = 2000; // 2ç§’åæ·¡å‡ºæç¤º
                            this.showMessage('æ¸¸æˆå¼€å§‹', 'info');
                            // è®¾ç½®åˆå§‹ç§»åŠ¨æ–¹å‘
                            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                                this.state.dx = 1;
                                this.state.dy = 0;
                            }
                            return;
                        }

                        let directionChanged = false;
                        switch(e.key) {
                            case 'ArrowUp':
                            case 'w':
                            case 'W':
                                if (this.state.dy !== 1) { 
                                    this.state.dx = 0; 
                                    this.state.dy = -1;
                                    directionChanged = true;
                                }
                                break;
                            case 'ArrowDown':
                            case 's':
                            case 'S':
                                if (this.state.dy !== -1) { 
                                    this.state.dx = 0; 
                                    this.state.dy = 1;
                                    directionChanged = true;
                                }
                                break;
                            case 'ArrowLeft':
                            case 'a':
                            case 'A':
                                if (this.state.dx !== 1) { 
                                    this.state.dx = -1; 
                                    this.state.dy = 0;
                                    directionChanged = true;
                                }
                                break;
                            case 'ArrowRight':
                            case 'd':
                            case 'D':
                                if (this.state.dx !== -1) { 
                                    this.state.dx = 1; 
                                    this.state.dy = 0;
                                    directionChanged = true;
                                }
                                break;
                        }

                        // å¦‚æœç”¨æˆ·æ”¹å˜äº†æ–¹å‘,æš‚æ—¶ç¦ç”¨AIæ§åˆ¶
                        if (directionChanged && this.state.isAIEnabled) {
                            this.state.path = []; // æ¸…ç©ºAIè·¯å¾„
                            this.state.userControlTimeout = 200; // è®¾ç½®0.2ç§’çš„ç”¨æˆ·æ§åˆ¶æ—¶é—´
                        }
                    });

                    // éš¾åº¦é€‰æ‹©
                    this.elements.difficulty.addEventListener('change', (e) => {
                        this.state.difficulty = parseInt(e.target.value);
                    });

                    // AIæ§åˆ¶
                    this.elements.aiToggle.addEventListener('click', () => {
                        this.state.isAIEnabled = !this.state.isAIEnabled;
                        
                        // å¦‚æœæ¸¸æˆæœªå¼€å§‹ï¼Œç‚¹å‡»AIæ‰˜ç®¡æŒ‰é’®ä¹Ÿå¯ä»¥å¼€å§‹æ¸¸æˆ
                        if (!this.state.gameStarted) {
                            this.state.gameStarted = true;
                            this.state.showTips = true;
                            this.state.tipsFadeOut = 2000; // 2ç§’åæ·¡å‡ºæç¤º
                            // è®¾ç½®åˆå§‹ç§»åŠ¨æ–¹å‘ï¼Œé¿å…AIè›‡åœåœ¨åŸåœ°
                            if (this.state.isAIEnabled) {
                                this.state.dx = 1; // é»˜è®¤å‘å³ç§»åŠ¨
                                this.state.dy = 0;
                            }
                        }
                        
                        this.elements.aiToggle.textContent = 
                            this.state.isAIEnabled ? "å–æ¶ˆæ‰˜ç®¡" : "AIæ‰˜ç®¡";
                    });

                    // çª—å£å¤§å°å˜åŒ–
                    window.addEventListener('resize', () => {
                        this.initCanvas();
                    });

                    // æ·»åŠ é¼ æ ‡å’Œè§¦æ‘¸æ§åˆ¶
                    let startX = 0;
                    let startY = 0;
                    let isMouseDown = false;
                    const minSwipeDistance = 30; // æœ€å°æ»‘åŠ¨è·ç¦»

                    // é¼ æ ‡æ§åˆ¶
                    this.canvas.addEventListener('mousedown', (e) => {
                        isMouseDown = true;
                        startX = e.clientX;
                        startY = e.clientY;

                        if (this.state.isGameOver) {
                            if (this.state.resetCountdown <= 0) {
                                this.resetGame();
                            }
                            return;
                        }

                        if (!this.state.gameStarted) {
                            this.state.gameStarted = true;
                            return;
                        }
                    });

                    this.canvas.addEventListener('mousemove', (e) => {
                        if (!isMouseDown) return;
                        
                        const deltaX = e.clientX - startX;
                        const deltaY = e.clientY - startY;
                        
                        // ç¡®ä¿æ»‘åŠ¨è·ç¦»è¶³å¤Ÿé•¿
                        if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance) {
                            return;
                        }
                        
                        // æ›´æ–°èµ·å§‹ä½ç½®ï¼Œä½¿ç§»åŠ¨æ›´æµç•…
                        startX = e.clientX;
                        startY = e.clientY;
                        
                        const prevDx = this.state.dx;
                        const prevDy = this.state.dy;
                        this.handleSwipe(deltaX, deltaY);
                        
                        // å¦‚æœæ–¹å‘æ”¹å˜ä¸”AIå¯ç”¨,æš‚æ—¶ç¦ç”¨AIæ§åˆ¶
                        if ((prevDx !== this.state.dx || prevDy !== this.state.dy) && this.state.isAIEnabled) {
                            this.state.path = [];
                            this.state.userControlTimeout = 200;
                        }
                    });

                    this.canvas.addEventListener('mouseup', () => {
                        isMouseDown = false;
                    });

                    this.canvas.addEventListener('mouseleave', () => {
                        isMouseDown = false;
                    });

                    // è§¦æ‘¸æ§åˆ¶
                    this.canvas.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        startX = e.touches[0].clientX;
                        startY = e.touches[0].clientY;

                        if (this.state.isGameOver) {
                            if (this.state.resetCountdown <= 0) {
                                this.resetGame();
                            }
                            return;
                        }

                        if (!this.state.gameStarted) {
                            this.state.gameStarted = true;
                            return;
                        }
                    });

                    this.canvas.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        
                        const deltaX = e.touches[0].clientX - startX;
                        const deltaY = e.touches[0].clientY - startY;
                        
                        // ç¡®ä¿æ»‘åŠ¨è·ç¦»è¶³å¤Ÿé•¿
                        if (Math.abs(deltaX) < minSwipeDistance && Math.abs(deltaY) < minSwipeDistance) {
                            return;
                        }
                        
                        // æ›´æ–°èµ·å§‹ä½ç½®ï¼Œä½¿ç§»åŠ¨æ›´æµç•…
                        startX = e.touches[0].clientX;
                        startY = e.touches[0].clientY;
                        
                        const prevDx = this.state.dx;
                        const prevDy = this.state.dy;
                        this.handleSwipe(deltaX, deltaY);
                        
                        // å¦‚æœæ–¹å‘æ”¹å˜ä¸”AIå¯ç”¨,æš‚æ—¶ç¦ç”¨AIæ§åˆ¶
                        if ((prevDx !== this.state.dx || prevDy !== this.state.dy) && this.state.isAIEnabled) {
                            this.state.path = [];
                            this.state.userControlTimeout = 200;
                        }
                    });

                    // æ·»åŠ ç»Ÿä¸€çš„æ»‘åŠ¨å¤„ç†æ–¹æ³•
                    this.handleSwipe = function(deltaX, deltaY) {
                        // åˆ¤æ–­ä¸»è¦æ»‘åŠ¨æ–¹å‘
                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                            // æ°´å¹³æ»‘åŠ¨
                            if (deltaX > 0 && this.state.dx !== -1) {
                                // å‘å³æ»‘åŠ¨
                                this.state.dx = 1;
                                this.state.dy = 0;
                            } else if (deltaX < 0 && this.state.dx !== 1) {
                                // å‘å·¦æ»‘åŠ¨
                                this.state.dx = -1;
                                this.state.dy = 0;
                            }
                        } else {
                            // å‚ç›´æ»‘åŠ¨
                            if (deltaY > 0 && this.state.dy !== -1) {
                                // å‘ä¸‹æ»‘åŠ¨
                                this.state.dx = 0;
                                this.state.dy = 1;
                            } else if (deltaY < 0 && this.state.dy !== 1) {
                                // å‘ä¸Šæ»‘åŠ¨
                                this.state.dx = 0;
                                this.state.dy = -1;
                            }
                        }
                    };
                },

                // æ·»åŠ AIç›¸å…³æ–¹æ³•
                updateAI() {
                    // å¦‚æœå¤„äºç”¨æˆ·æ§åˆ¶æ—¶é—´å†…,è·³è¿‡AIæ§åˆ¶
                    if (this.state.userControlTimeout > 0) {
                        this.state.userControlTimeout -= this.state.difficulty;
                        return;
                    }

                    // ç¡®ä¿pathå­˜åœ¨ä¸”ä¸ºæ•°ç»„
                    if (!Array.isArray(this.state.path)) {
                        this.state.path = [];
                    }
                    
                    if (this.state.path.length === 0) {
                        const newPath = this.findPath();
                        this.state.path = newPath || []; // å¦‚æœfindPathè¿”å›nullï¼Œä½¿ç”¨ç©ºæ•°ç»„
                    }
                    
                    if (this.state.path.length > 0) {
                        const [dx, dy] = this.state.path.shift();
                        this.state.dx = dx;
                        this.state.dy = dy;
                    } else {
                        this.avoidCollision();
                    }
                },

                findPath() {
                    const MAX_SEARCH_DEPTH = 1000; // å¢åŠ æœç´¢æ·±åº¦ä»¥æé«˜å¯»è·¯å‡†ç¡®æ€§
                    const start = this.state.snake[0];
                    const target = this.state.food;
                    
                    // ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–æœç´¢æ•ˆç‡
                    class PriorityQueue {
                        constructor() {
                            this.values = [];
                        }
                        
                        enqueue(node, priority) {
                            this.values.push({node, priority});
                            this.sort();
                        }
                        
                        dequeue() {
                            return this.values.shift().node;
                        }
                        
                        sort() {
                            this.values.sort((a, b) => a.priority - b.priority);
                        }
                    }

                    class Node {
                        constructor(x, y, parent = null) {
                            this.x = x;
                            this.y = y;
                            this.parent = parent;
                            this.g = parent ? parent.g + 1 : 0;
                            this.h = Math.abs(x - target.x) + Math.abs(y - target.y);
                            this.f = this.g + this.h;
                        }
                    }

                    const openList = new PriorityQueue();
                    openList.enqueue(new Node(start.x, start.y), 0);
                    const closedList = new Set();
                    const snakePositions = new Set(
                        this.state.snake.map(s => `${s.x},${s.y}`)
                    );

                    let searchCount = 0;
                    while (openList.values.length > 0 && searchCount++ < MAX_SEARCH_DEPTH) {
                        const currentNode = openList.dequeue();

                        if (currentNode.x === target.x && currentNode.y === target.y) {
                            const path = [];
                            let node = currentNode;
                            while (node.parent) {
                                path.unshift([
                                    node.x - node.parent.x,
                                    node.y - node.parent.y
                                ]);
                                node = node.parent;
                            }
                            this.logAIThinking('path_found', { path });
                            return path;
                        }

                        const key = `${currentNode.x},${currentNode.y}`;
                        if (closedList.has(key)) continue;
                        closedList.add(key);

                        // ä¼˜åŒ–æ–¹å‘æœç´¢
                        const directions = this.getOptimalDirections(currentNode, target);
                        for (const [dx, dy] of directions) {
                            const nx = currentNode.x + dx;
                            const ny = currentNode.y + dy;
                            const newKey = `${nx},${ny}`;

                            if (
                                nx < 0 || nx >= this.tileCount ||
                                ny < 0 || ny >= this.tileCount ||
                                snakePositions.has(newKey) ||
                                closedList.has(newKey)
                            ) continue;

                            const newNode = new Node(nx, ny, currentNode);
                            openList.enqueue(newNode, newNode.f);
                        }
                    }

                    this.logAIThinking('path_failed', {});
                    return null;
                },

                // æ·»åŠ æ–°æ–¹æ³•ï¼šè·å–æœ€ä¼˜æœç´¢æ–¹å‘
                getOptimalDirections(current, target) {
                    const dx = target.x - current.x;
                    const dy = target.y - current.y;
                    const directions = [];
                    
                    // ä¼˜å…ˆè€ƒè™‘ç›´æ¥æœå‘ç›®æ ‡çš„æ–¹å‘
                    if (Math.abs(dx) > Math.abs(dy)) {
                        directions.push([Math.sign(dx), 0]);
                        directions.push([0, Math.sign(dy)]);
                        directions.push([0, -Math.sign(dy)]);
                        directions.push([-Math.sign(dx), 0]);
                    } else {
                        directions.push([0, Math.sign(dy)]);
                        directions.push([Math.sign(dx), 0]);
                        directions.push([-Math.sign(dx), 0]);
                        directions.push([0, -Math.sign(dy)]);
                    }
                    
                    return directions;
                },

                // è®¡ç®—ç©ºé—´å¾—åˆ† - è¯„ä¼°æŸä¸ªä½ç½®å‘¨å›´çš„å¯ç”¨ç©ºé—´
                calculateSpaceScore(position) {
                    let score = 0;
                    const visited = new Set();
                    const queue = [position];
                    const maxDepth = 8; // é™åˆ¶æœç´¢æ·±åº¦
                    
                    visited.add(`${position.x},${position.y}`);
                    
                    while (queue.length > 0 && visited.size < maxDepth) {
                        const current = queue.shift();
                        score += 1;
                        
                        // æ£€æŸ¥å››ä¸ªæ–¹å‘
                        const directions = [[0,1], [1,0], [0,-1], [-1,0]];
                        for (const [dx, dy] of directions) {
                            const newX = current.x + dx;
                            const newY = current.y + dy;
                            const key = `${newX},${newY}`;
                            
                            if (newX < 0 || newX >= this.tileCount || 
                                newY < 0 || newY >= this.tileCount ||
                                visited.has(key) ||
                                this.state.snake.some(s => s.x === newX && s.y === newY)) {
                                continue;
                            }
                            
                            visited.add(key);
                            queue.push({x: newX, y: newY});
                        }
                    }
                    
                    return score / maxDepth; // å½’ä¸€åŒ–å¾—åˆ†
                },

                // è®¡ç®—é£Ÿç‰©å¾—åˆ† - è¯„ä¼°æŸä¸ªä½ç½®åˆ°é£Ÿç‰©çš„è·ç¦»
                calculateFoodScore(position) {
                    const distance = Math.abs(position.x - this.state.food.x) + 
                                    Math.abs(position.y - this.state.food.y);
                    return 1 / (distance + 1); // è·ç¦»è¶Šè¿‘åˆ†æ•°è¶Šé«˜
                },

                // è®¡ç®—å®‰å…¨åº¦åˆ†æ•° - è¯„ä¼°æŸä¸ªä½ç½®çš„å®‰å…¨ç¨‹åº¦
                calculateSafetyScore(position) {
                    let score = 0;
                    const directions = [[1,0], [-1,0], [0,1], [0,-1]];
                    
                    for (const [dx, dy] of directions) {
                        const nextPos = {
                            x: position.x + dx,
                            y: position.y + dy
                        };
                        
                        if (!this.checkCollision(nextPos)) {
                            score += 0.25;
                            
                            // é¢å¤–æ£€æŸ¥ç¬¬äºŒå±‚ç§»åŠ¨ç©ºé—´
                            for (const [dx2, dy2] of directions) {
                                const nextPos2 = {
                                    x: nextPos.x + dx2,
                                    y: nextPos.y + dy2
                                };
                                if (!this.checkCollision(nextPos2)) {
                                    score += 0.1;
                                }
                            }
                        }
                    }
                    
                    return score;
                },

                // ä¼˜åŒ–é¿éšœç®—æ³•
                avoidCollision() {
                    const directions = [[1,0], [-1,0], [0,1], [0,-1]]
                        .filter(([dx, dy]) => dx !== -this.state.dx || dy !== -this.state.dy);

                    const safeDirections = directions.map(([dx, dy]) => {
                        const newHead = {
                            x: this.state.snake[0].x + dx,
                            y: this.state.snake[0].y + dy
                        };
                        
                        if (this.checkCollision(newHead)) {
                            return { direction: [dx, dy], score: -Infinity };
                        }

                        const spaceScore = this.calculateSpaceScore(newHead) * 4;
                        const foodScore = this.calculateFoodScore(newHead) * 3;
                        const safetyScore = this.calculateSafetyScore(newHead) * 2;
                        
                        return {
                            direction: [dx, dy],
                            score: spaceScore + foodScore + safetyScore + Math.random() * 0.1
                        };
                    }).filter(dir => dir.score > -Infinity);

                    if (safeDirections.length > 0) {
                        const bestDirection = safeDirections.reduce((best, current) => 
                            current.score > best.score ? current : best
                        );

                        this.logAIThinking('decision', {
                            direction: bestDirection.direction,
                            score: bestDirection.score.toFixed(2)
                        });

                        [this.state.dx, this.state.dy] = bestDirection.direction;
                    } else {
                        this.logAIThinking('collision_risk', {
                            message: "æ— å®‰å…¨è·¯å¾„å¯èµ°"
                        });
                    }
                },

                logAIThinking(type, data) {
                    if (!this.elements.debugToggle.checked) return;
                    
                    const now = Date.now();
                    if (!this.lastLogTime) this.lastLogTime = 0;
                    if (!this.logEntries) this.logEntries = [];

                    if (now - this.lastLogTime > 200) {
                        const entry = {
                            timestamp: now,
                            type: type,
                            data: data
                        };

                        this.logEntries.push(entry);
                        this.updateDebugView();
                        this.lastLogTime = now;
                    }
                },

                updateDebugView() {
                    const maxLines = 10;
                    const types = {
                        path_found: 'æ‰¾åˆ°è·¯å¾„',
                        path_failed: 'è·¯å¾„å¯»æ‰¾å¤±è´¥ï¼Œå¯åŠ¨é¿é™©',
                        collision_risk: 'æ£€æµ‹åˆ°ç¢°æ’é£é™©',
                        decision: 'å†³ç­–æ–¹å‘'
                    };

                    this.elements.debugLog.innerHTML = this.logEntries
                        .slice(-maxLines)
                        .map(entry => {
                            const time = new Date(entry.timestamp)
                                .toLocaleTimeString('zh-CN', { 
                                    hour12: false,
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    second: '2-digit'
                                });
                            return `<div style="border-bottom: 1px solid #4CAF50; padding: 2px 0;">
                                [${time}] ${types[entry.type]}<br>
                                ${JSON.stringify(entry.data)}
                            </div>`;
                        })
                        .join('');
                },

                drawGameOver() {
                    const countdown = Math.ceil(this.state.resetCountdown / 1000);
                    const text = countdown > 0 ? 
                        `æ¸¸æˆç»“æŸï¼${countdown}ç§’åå¯é‡æ–°å¼€å§‹` : 
                        "æ¸¸æˆç»“æŸï¼æŒ‰ä»»æ„é”®é‡æ–°å¼€å§‹";

                    this.ctx.save();
                    
                    // ç»˜åˆ¶åŠé€æ˜èƒŒæ™¯
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // è®¾ç½®æ–‡å­—æ ·å¼
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    // ç»˜åˆ¶å‘å…‰æ•ˆæœ
                    this.ctx.shadowColor = '#FF0000';
                    this.ctx.shadowBlur = 10;
                    this.ctx.fillStyle = '#FF0000';
                    this.ctx.fillText(text, this.canvas.width/2, this.canvas.height/2);

                    // æ˜¾ç¤ºæœ€ç»ˆå¾—åˆ†
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.fillStyle = '#4CAF50';
                    this.ctx.shadowColor = '#4CAF50';
                    this.ctx.fillText(
                        `æœ€ç»ˆå¾—åˆ†: ${this.state.score}`, 
                        this.canvas.width/2, 
                        this.canvas.height/2 + 40
                    );
                    
                    this.ctx.restore();
                },

                drawStartPrompt() {
                    const text = "æŒ‰ä»»æ„é”®æˆ–æ»‘åŠ¨å¼€å§‹æ¸¸æˆ";
                    const controlTip = "WASD/æ–¹å‘é”®/æ»‘åŠ¨æ§åˆ¶ | ç©ºæ ¼æš‚åœ";
                    this.ctx.save();
                    
                    // ç»˜åˆ¶åŠé€æ˜èƒŒæ™¯
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // è®¾ç½®æ–‡å­—æ ·å¼
                    this.ctx.font = 'bold 28px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    // ç»˜åˆ¶å‘å…‰æ•ˆæœ
                    this.ctx.shadowColor = '#4CAF50';
                    this.ctx.shadowBlur = 15;
                    this.ctx.fillStyle = '#4CAF50';
                    this.ctx.fillText(text, this.canvas.width/2, this.canvas.height/2 - 30);
                    
                    // æ·»åŠ æ§åˆ¶æç¤º
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.fillText(controlTip, this.canvas.width/2, this.canvas.height/2 + 20);
                    
                    this.ctx.restore();
                },

                drawPausePrompt() {
                    this.ctx.save();
                    
                    // ç»˜åˆ¶åŠé€æ˜èƒŒæ™¯
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // è®¾ç½®æ–‡å­—æ ·å¼
                    this.ctx.font = 'bold 32px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    // ç»˜åˆ¶å‘å…‰æ•ˆæœ
                    this.ctx.shadowColor = '#FFC107';
                    this.ctx.shadowBlur = 15;
                    this.ctx.fillStyle = '#FFC107';
                    this.ctx.fillText('æ¸¸æˆæš‚åœ', this.canvas.width/2, this.canvas.height/2 - 30);
                    
                    // æ·»åŠ æç¤º
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.fillText('æŒ‰ç©ºæ ¼é”®ç»§ç»­', this.canvas.width/2, this.canvas.height/2 + 20);
                    
                    this.ctx.restore();
                },

                drawControlTips() {
                    if (!this.state.showTips) return;
                    
                    // æ›´æ–°tipsFadeOutå€¼
                    if (this.state.tipsFadeOut > 0) {
                        this.state.tipsFadeOut = Math.max(0, this.state.tipsFadeOut - this.state.difficulty);
                    }
                    
                    this.ctx.save();
                    
                    // è®¡ç®—é€æ˜åº¦
                    let alpha = 0.7;
                    if (this.state.tipsFadeOut > 0) {
                        alpha = (this.state.tipsFadeOut / 2000) * 0.7;
                    }
                    
                    // å¦‚æœé€æ˜åº¦å¤ªä½å°±ä¸ç»˜åˆ¶
                    if (alpha < 0.05) {
                        this.state.showTips = false;
                        this.ctx.restore();
                        return;
                    }
                    
                    // è®¾ç½®æ–‡å­—æ ·å¼
                    this.ctx.font = '16px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillStyle = `rgba(76, 175, 80, ${alpha})`;
                    
                    // ç»˜åˆ¶æ§åˆ¶æç¤º
                    const tips = [
                        'ğŸ® æ“ä½œæç¤º',
                        'â†‘â†“â†â†’ / WASDï¼šç§»åŠ¨',
                        'ç©ºæ ¼é”®ï¼šæš‚åœ/ç»§ç»­',
                        'è§¦æ§/é¼ æ ‡ï¼šæ»‘åŠ¨æ§åˆ¶',
                        'AIæ‰˜ç®¡ï¼šè‡ªåŠ¨å¯»è·¯'
                    ];
                    
                    const padding = 15;
                    const lineHeight = 25;
                    const boxPadding = 10;
                    
                    // è®¡ç®—æç¤ºæ¡†çš„å¤§å°
                    const boxWidth = Math.max(...tips.map(tip => this.ctx.measureText(tip).width)) + (boxPadding * 2);
                    const boxHeight = (tips.length * lineHeight) + (boxPadding * 2);
                    
                    // ç»˜åˆ¶åŠé€æ˜èƒŒæ™¯
                    this.ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.7})`;
                    this.ctx.roundRect(
                        padding - boxPadding,
                        this.canvas.height - boxHeight - padding + boxPadding,
                        boxWidth,
                        boxHeight,
                        5
                    );
                    this.ctx.fill();
                    
                    // ç»˜åˆ¶æç¤ºæ–‡æœ¬
                    this.ctx.fillStyle = `rgba(76, 175, 80, ${alpha})`;
                    tips.forEach((tip, index) => {
                        this.ctx.fillText(
                            tip,
                            padding,
                            this.canvas.height - ((tips.length - index) * lineHeight) - padding
                        );
                    });
                    
                    // åœ¨å³ä¸‹è§’æ˜¾ç¤ºå½“å‰éš¾åº¦
                    const difficultyText = `ğŸ¯ ${this.getDifficultyName()}`;
                    this.ctx.textAlign = 'right';
                    this.ctx.fillText(
                        difficultyText,
                        this.canvas.width - padding,
                        this.canvas.height - padding
                    );
                    
                    this.ctx.restore();
                },

                getDifficultyName() {
                    const difficultyMap = {
                        100: 'èŒæ–°æ¨¡å¼',
                        80: 'ç®€å•æ¨¡å¼',
                        60: 'æ™®é€šæ¨¡å¼',
                        40: 'å›°éš¾æ¨¡å¼',
                        20: 'åœ°ç‹±æ¨¡å¼'
                    };
                    return difficultyMap[this.state.difficulty] || 'æ™®é€šæ¨¡å¼';
                },

                // å¼€å§‹å›æ”¾
                startReplay(index) {
                    if (index >= 5) {
                        this.showMessage('åªèƒ½å›æ”¾æœ€è¿‘5å±€æ¸¸æˆè®°å½•', 'warning');
                        return;
                    }
                    
                    const record = this.gameHistory[index];
                    if (!record || !record.moves || record.moves.length === 0) {
                        this.showMessage('å›æ”¾æ•°æ®æ— æ•ˆæˆ–å·²æŸå', 'error');
                        return;
                    }

                    // é‡ç½®æ¸¸æˆçŠ¶æ€
                    this.resetGame();
                    
                    // è®¾ç½®åˆå§‹çŠ¶æ€
                    this.state.snake = [{x: 10, y: 10}];  // å›ºå®šåˆå§‹ä½ç½®
                    this.state.food = {x: 15, y: 15};     // å›ºå®šåˆå§‹é£Ÿç‰©ä½ç½®
                    this.state.score = 0;
                    this.state.dx = 1;
                    this.state.dy = 0;
                    
                    // è®¾ç½®å›æ”¾çŠ¶æ€
                    this.state.isReplaying = true;
                    this.state.replayPaused = false;
                    this.state.replaySpeed = 1;
                    this.state.moveHistory = [...record.moves];
                    this.state.gameStarted = true;
                    this.state.difficulty = record.difficulty;
                    
                    // ä¿å­˜é£Ÿç‰©å†å²
                    this.replayFoodHistory = [...(record.foodHistory || [])];
                    this.replayFoodIndex = 0;
                    this.replaySnakeGrowth = record.snakeGrowth || 0;
                    
                    // æ˜¾ç¤ºå›æ”¾ç•Œé¢
                    document.getElementById('historyPanel').style.display = 'none';
                    document.getElementById('replayOverlay').style.display = 'block';
                    document.getElementById('replayControls').style.display = 'block';
                    document.getElementById('replayPause').textContent = 'æš‚åœ';
                    document.getElementById('replaySpeed').value = '1';

                    this.elements.score.textContent = `å¾—åˆ†: 0`;
                    this.showMessage('å¼€å§‹å›æ”¾', 'info');
                    
                    // å¼€å§‹å›æ”¾
                    this.replayNextMove();
                },

                replayNextMove() {
                    if (!this.state.isReplaying || this.state.replayPaused) return;

                    if (this.state.moveHistory.length > 0) {
                        const [dx, dy] = this.state.moveHistory.shift();
                        
                        // æ›´æ–°è›‡çš„ä½ç½®
                        const head = { 
                            x: this.state.snake[0].x + dx, 
                            y: this.state.snake[0].y + dy 
                        };

                        // æ£€æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
                        const ate = head.x === this.state.food.x && head.y === this.state.food.y;
                        
                        // æ›´æ–°è›‡çš„èº«ä½“
                        this.state.snake.unshift(head);
                        if (!ate) {
                            this.state.snake.pop();
                        } else {
                            // å¦‚æœåƒåˆ°é£Ÿç‰©ï¼Œæ›´æ–°åˆ†æ•°å’Œé£Ÿç‰©ä½ç½®
                            this.state.score += 10;
                            this.elements.score.textContent = `å¾—åˆ†: ${this.state.score}`;
                            
                            // ä½¿ç”¨è®°å½•çš„é£Ÿç‰©ä½ç½®
                            if (this.replayFoodHistory && this.replayFoodHistory[this.replayFoodIndex]) {
                                this.state.food = {...this.replayFoodHistory[this.replayFoodIndex]};
                                this.replayFoodIndex++;
                            }
                        }

                        // æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
                        if (this.checkCollision(head)) {
                            this.stopReplay();
                            return;
                        }
                        
                        // æ ¹æ®å›æ”¾é€Ÿåº¦è®¾ç½®ä¸‹ä¸€æ­¥çš„å»¶æ—¶
                        const speed = parseFloat(document.getElementById('replaySpeed').value);
                        setTimeout(() => this.replayNextMove(), this.state.difficulty / speed);
                    } else {
                        this.stopReplay();
                    }
                },

                stopReplay() {
                    this.state.isReplaying = false;
                    this.state.replayPaused = false;
                    document.getElementById('replayOverlay').style.display = 'none';
                    document.getElementById('replayControls').style.display = 'none';
                    
                    // æ¢å¤åŸå§‹çŠ¶æ€
                    if (this.state.originalSnake) {
                        this.state.snake = [...this.state.originalSnake];
                    }
                    if (this.state.originalFood) {
                        this.state.food = {...this.state.originalFood};
                    }
                    
                    this.resetGame();
                    this.showMessage('å›æ”¾ç»“æŸ', 'info');
                },

                // æ˜¾ç¤ºæ¶ˆæ¯æç¤º
                showMessage(text, type = 'info') {
                    // å¦‚æœå·²ç»å­˜åœ¨æ¶ˆæ¯æ¡†ï¼Œå…ˆç§»é™¤
                    const existingMsg = document.querySelector('.game-message');
                    if (existingMsg) {
                        existingMsg.remove();
                    }

                    const colors = {
                        info: '#4CAF50',
                        warning: '#FFC107',
                        error: '#FF5252'
                    };

                    const msgBox = document.createElement('div');
                    msgBox.className = 'game-message';
                    msgBox.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0, 0, 0, 0.8);
                        color: ${colors[type]};
                        padding: 10px 20px;
                        border-radius: 20px;
                        font-size: 16px;
                        z-index: 1002;
                        border: 1px solid ${colors[type]};
                        box-shadow: 0 0 10px ${colors[type]};
                    `;
                    
                    const icon = type === 'info' ? 'ğŸ’¡' : type === 'warning' ? 'âš ï¸' : 'âŒ';
                    msgBox.textContent = `${icon} ${text}`;
                    
                    document.body.appendChild(msgBox);
                    
                    // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
                    setTimeout(() => {
                        msgBox.style.opacity = '0';
                        msgBox.style.transition = 'opacity 0.5s ease';
                        setTimeout(() => msgBox.remove(), 500);
                    }, 3000);
                },

                // æ·»åŠ ç‰¹æ•ˆ
                addEffect(type, x, y, text) {
                    const effect = {
                        type,
                        x: x * this.CONFIG.GRID_SIZE,
                        y: y * this.CONFIG.GRID_SIZE,
                        duration: 500,
                        text
                    };
                    this.state.effects.push(effect);
                },

                // æ·»åŠ é“å…·
                addPowerup() {
                    const powerups = [
                        { type: 'speed', duration: 5000, effect: () => this.state.difficulty *= 0.8 },
                        { type: 'shield', duration: 3000 },
                        { type: 'score2x', duration: 10000 }
                    ];
                    
                    const powerup = powerups[Math.floor(Math.random() * powerups.length)];
                    this.state.powerups.push(powerup);
                    
                    if (powerup.effect) {
                        powerup.effect();
                    }
                    
                    this.showMessage(`è·å¾—é“å…·: ${this.getPowerupName(powerup.type)}`, 'info');
                },

                getPowerupName(type) {
                    const names = {
                        'speed': 'åŠ é€Ÿ',
                        'shield': 'æŠ¤ç›¾',
                        'score2x': 'åŒå€å¾—åˆ†'
                    };
                    return names[type] || type;
                },

                // ç»˜åˆ¶çˆ†ç‚¸ç‰¹æ•ˆ
                drawExplosion(effect) {
                    const radius = (500 - effect.duration) / 10;
                    this.ctx.strokeStyle = '#FF5252';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(effect.x + this.CONFIG.GRID_SIZE/2, 
                                 effect.y + this.CONFIG.GRID_SIZE/2, 
                                 radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                },

                // ç»˜åˆ¶åƒé£Ÿç‰©ç‰¹æ•ˆ
                drawEatEffect(effect) {
                    const size = this.CONFIG.GRID_SIZE * (1 + (500 - effect.duration) / 500);
                    this.ctx.fillStyle = '#4CAF50';
                    this.ctx.beginPath();
                    this.ctx.arc(effect.x + this.CONFIG.GRID_SIZE/2, 
                                 effect.y + this.CONFIG.GRID_SIZE/2, 
                                 size/4, 0, Math.PI * 2);
                    this.ctx.fill();
                },

                // ç»˜åˆ¶è¿å‡»ç‰¹æ•ˆ
                drawComboEffect(effect) {
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.fillStyle = '#FFC107';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(effect.text, 
                                     effect.x + this.CONFIG.GRID_SIZE/2,
                                     effect.y - (500 - effect.duration) / 50);
                },

                // ç»˜åˆ¶ç‰¹æ®Šæ•ˆæœ
                drawSpecialEffect(effect) {
                    const size = this.CONFIG.GRID_SIZE * 2;
                    this.ctx.strokeStyle = '#FF5722';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(effect.x + this.CONFIG.GRID_SIZE/2, 
                                 effect.y + this.CONFIG.GRID_SIZE/2, 
                                 size * (1 - effect.duration/500), 0, Math.PI * 2);
                    this.ctx.stroke();
                },

                // ç»˜åˆ¶é“å…·çŠ¶æ€
                drawPowerups() {
                    const padding = 10;
                    const iconSize = 30;
                    let offsetY = padding;

                    this.state.powerups.forEach(powerup => {
                        const timeLeft = Math.ceil(powerup.duration / 1000);
                        
                        this.ctx.save();
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        this.ctx.roundRect(padding, offsetY, iconSize * 4, iconSize, 5);
                        this.ctx.fill();
                        
                        this.ctx.font = '16px Arial';
                        this.ctx.fillStyle = '#FFF';
                        this.ctx.textAlign = 'left';
                        this.ctx.fillText(`${this.getPowerupName(powerup.type)} ${timeLeft}s`, 
                                         padding + iconSize + 5, 
                                         offsetY + iconSize/2 + 5);
                        
                        offsetY += iconSize + padding;
                        this.ctx.restore();
                    });
                },
            };

        // åˆå§‹åŒ–æ¸¸æˆ
            window.addEventListener('DOMContentLoaded', () => Game.init());
        })();
    </script>
</body>
</html> 